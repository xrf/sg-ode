<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sg-ode: sg_ode/ode.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sg-ode
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_25e906b934a9b902a566a0f8d5544477.html">sg_ode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ode.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>ODE solver by Shampine and Gordon.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &quot;<a class="el" href="vector_8h_source.html">vector.h</a>&quot;</code><br />
<code>#include &quot;extern.h&quot;</code><br />
<code>#include &quot;restrict_begin.h&quot;</code><br />
<code>#include &quot;restrict_end.h&quot;</code><br />
</div>
<p><a href="ode_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a6d090f9c9d67b32ab6de6dfd61129d25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#a6d090f9c9d67b32ab6de6dfd61129d25">SG_ODE_FSTRICT</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:a6d090f9c9d67b32ab6de6dfd61129d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do not integrate beyond the target.  <a href="#a6d090f9c9d67b32ab6de6dfd61129d25">More...</a><br /></td></tr>
<tr class="separator:a6d090f9c9d67b32ab6de6dfd61129d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3724c41ea6f775b552308803e67cd0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#a8b3724c41ea6f775b552308803e67cd0">SG_ODE_FMAXNUM</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:a8b3724c41ea6f775b552308803e67cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the value of iwork[5] to set the maximum number of iterations.  <a href="#a8b3724c41ea6f775b552308803e67cd0">More...</a><br /></td></tr>
<tr class="separator:a8b3724c41ea6f775b552308803e67cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8b7658ea6af4651ddd33f0446b1d45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#acd8b7658ea6af4651ddd33f0446b1d45">SG_ODE_ETOLER</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:acd8b7658ea6af4651ddd33f0446b1d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration did not reach target because the error tolerances were too small given the limitations of machine precision.  <a href="#acd8b7658ea6af4651ddd33f0446b1d45">More...</a><br /></td></tr>
<tr class="separator:acd8b7658ea6af4651ddd33f0446b1d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4839531a8ce62974ea90edf01ff655"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#aaa4839531a8ce62974ea90edf01ff655">SG_ODE_ESTEPS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:aaa4839531a8ce62974ea90edf01ff655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration did not reach target because more than <code>maxnum</code> steps were taken.  <a href="#aaa4839531a8ce62974ea90edf01ff655">More...</a><br /></td></tr>
<tr class="separator:aaa4839531a8ce62974ea90edf01ff655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05366a844e2aba52b77f70c26be15bab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#a05366a844e2aba52b77f70c26be15bab">SG_ODE_ESTIFF</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a05366a844e2aba52b77f70c26be15bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integration did not reach target because more than <code>maxnum</code> steps were taken.  <a href="#a05366a844e2aba52b77f70c26be15bab">More...</a><br /></td></tr>
<tr class="separator:a05366a844e2aba52b77f70c26be15bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd33ed2bf091a695a266897f25e4d099"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#afd33ed2bf091a695a266897f25e4d099">SG_ODE_EINVAL</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:afd33ed2bf091a695a266897f25e4d099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid argument(s).  <a href="#afd33ed2bf091a695a266897f25e4d099">More...</a><br /></td></tr>
<tr class="separator:afd33ed2bf091a695a266897f25e4d099"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae90bc8a3fc0bee518865c17e8e7b5bde"><td class="memItemLeft" align="right" valign="top"><a id="ae90bc8a3fc0bee518865c17e8e7b5bde"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>SgDerivFn</b>(void *f_ctx, double t, const <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict y, <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict yp)</td></tr>
<tr class="separator:ae90bc8a3fc0bee518865c17e8e7b5bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top"><a id="a06fc87d81c62e9abb8790b6e5713c55b"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SG_ODE_TYPE_BOOL</b>, 
<b>SG_ODE_TYPE_DOUBLE</b>, 
<b>SG_ODE_TYPE_UNSIGNED</b>, 
<b>SG_ODE_TYPE_VECTOR</b>
 }</td></tr>
<tr class="separator:a06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aba74c2ed005171e9e1daf0c3a702e27c"><td class="memItemLeft" align="right" valign="top"><a id="aba74c2ed005171e9e1daf0c3a702e27c"></a>
struct <a class="el" href="structSgOde.html">SgOde</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>sg_ode_try_new</b> (struct <a class="el" href="structSgVectorDriver.html">SgVectorDriver</a> drv)</td></tr>
<tr class="separator:aba74c2ed005171e9e1daf0c3a702e27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ea14e9b48ff9038e263c179cbf5c7d"><td class="memItemLeft" align="right" valign="top"><a id="a11ea14e9b48ff9038e263c179cbf5c7d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sg_ode_del</b> (struct <a class="el" href="structSgOde.html">SgOde</a> *self)</td></tr>
<tr class="separator:a11ea14e9b48ff9038e263c179cbf5c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d09f244c282ee7e40601509cc158754"><td class="memItemLeft" align="right" valign="top"><a id="a3d09f244c282ee7e40601509cc158754"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sg_ode_traverse</b> (struct <a class="el" href="structSgOde.html">SgOde</a> *self, int(*f)(void *ctx, void *data, int type, size_t len), void *ctx)</td></tr>
<tr class="separator:a3d09f244c282ee7e40601509cc158754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7225fd894aa50d3fcf62d5c5b1d5df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#afb7225fd894aa50d3fcf62d5c5b1d5df">sg_ode_step</a> (struct <a class="el" href="structSgOde.html">SgOde</a> *self, SgDerivFn *f, void *restrict f_ctx, double *restrict eps)</td></tr>
<tr class="memdesc:afb7225fd894aa50d3fcf62d5c5b1d5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a system of first order ordinary differential equations one step, normally from <code>x</code> to <code>x+h</code>, using a modified divided difference form of the Adams PECE formulas.  <a href="#afb7225fd894aa50d3fcf62d5c5b1d5df">More...</a><br /></td></tr>
<tr class="separator:afb7225fd894aa50d3fcf62d5c5b1d5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ace58bd22a16a46d719739bf449a644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#a1ace58bd22a16a46d719739bf449a644">sg_ode_interpolate</a> (struct <a class="el" href="structSgVectorDriver.html">SgVectorDriver</a> drv, double x, const <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict y, double xout, <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict yout, <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict ypout, unsigned kold, <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *const restrict *phi, const double *restrict psi)</td></tr>
<tr class="memdesc:a1ace58bd22a16a46d719739bf449a644"><td class="mdescLeft">&#160;</td><td class="mdescRight">The methods in function <code>step</code> approximate the solution near <code>x</code> by a polynomial.  <a href="#a1ace58bd22a16a46d719739bf449a644">More...</a><br /></td></tr>
<tr class="separator:a1ace58bd22a16a46d719739bf449a644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef172a1555c391f633111a3b37d1daa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#aef172a1555c391f633111a3b37d1daa9">sg_ode_de</a> (struct <a class="el" href="structSgOde.html">SgOde</a> *self, SgDerivFn *f, void *restrict f_ctx, <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict y, double *restrict t, double tout, double *restrict relerr, double *restrict abserr, int *restrict iflag, unsigned maxnum)</td></tr>
<tr class="memdesc:aef172a1555c391f633111a3b37d1daa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a system of <code>neqn</code> first order ordinary differential equations.  <a href="#aef172a1555c391f633111a3b37d1daa9">More...</a><br /></td></tr>
<tr class="separator:aef172a1555c391f633111a3b37d1daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d27c5de78e113bb0604c6985d71ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ode_8h.html#a8e1d27c5de78e113bb0604c6985d71ea">sg_ode</a> (void *f_ctx, void(*f)(void *, double, const double *, double *), size_t neqn, double *restrict y, double *restrict t, double tout, double relerr, double abserr, int flag, double *restrict work, int *restrict iwork)</td></tr>
<tr class="memdesc:a8e1d27c5de78e113bb0604c6985d71ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple interface to the ODE solver.  <a href="#a8e1d27c5de78e113bb0604c6985d71ea">More...</a><br /></td></tr>
<tr class="separator:a8e1d27c5de78e113bb0604c6985d71ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>ODE solver by Shampine and Gordon. </p>
<p>This header provides two interfaces:</p>
<ul>
<li><code>sg_ode</code> offers the simplest interface and is compatible with earlier versions of this library.</li>
<li><code>sg_ode_try_new</code>, <code>sg_ode_de</code>, and <code>sg_ode_del</code> provide a more flexible interface with support for custom vector drivers, necessary for parallelization. </li>
</ul>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afd33ed2bf091a695a266897f25e4d099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd33ed2bf091a695a266897f25e4d099">&#9670;&nbsp;</a></span>SG_ODE_EINVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SG_ODE_EINVAL&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid argument(s). </p>

</div>
</div>
<a id="aaa4839531a8ce62974ea90edf01ff655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4839531a8ce62974ea90edf01ff655">&#9670;&nbsp;</a></span>SG_ODE_ESTEPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SG_ODE_ESTEPS&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integration did not reach target because more than <code>maxnum</code> steps were taken. </p>

</div>
</div>
<a id="a05366a844e2aba52b77f70c26be15bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05366a844e2aba52b77f70c26be15bab">&#9670;&nbsp;</a></span>SG_ODE_ESTIFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SG_ODE_ESTIFF&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integration did not reach target because more than <code>maxnum</code> steps were taken. </p>
<p>In particular, the equations appear to be stiff. </p>

</div>
</div>
<a id="acd8b7658ea6af4651ddd33f0446b1d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8b7658ea6af4651ddd33f0446b1d45">&#9670;&nbsp;</a></span>SG_ODE_ETOLER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SG_ODE_ETOLER&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integration did not reach target because the error tolerances were too small given the limitations of machine precision. </p>
<p>In the case of <code>sg_ode_de</code>, the <code>relerr</code> and <code>abserr</code> will have been updated to be more reasonable, and one may re-attempt solution with the arguments unchanged. </p>

</div>
</div>
<a id="a8b3724c41ea6f775b552308803e67cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3724c41ea6f775b552308803e67cd0">&#9670;&nbsp;</a></span>SG_ODE_FMAXNUM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SG_ODE_FMAXNUM&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the value of iwork[5] to set the maximum number of iterations. </p>
<p>Otherwise, the default of 500 is used. </p>

</div>
</div>
<a id="a6d090f9c9d67b32ab6de6dfd61129d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d090f9c9d67b32ab6de6dfd61129d25">&#9670;&nbsp;</a></span>SG_ODE_FSTRICT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SG_ODE_FSTRICT&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do not integrate beyond the target. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8e1d27c5de78e113bb0604c6985d71ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1d27c5de78e113bb0604c6985d71ea">&#9670;&nbsp;</a></span>sg_ode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sg_ode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>f_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *, double, const double *, double *)&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>neqn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&#160;</td>
          <td class="paramname"><em>work</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *restrict&#160;</td>
          <td class="paramname"><em>iwork</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple interface to the ODE solver. </p>
<p>This is the same interface that sg-ode has had in older versions. It is less flexible but may be easier to use for simple problems.</p>
<p>This interface does not support generic vectors or parallelized vector operations. It also does not allow resumption if the tolerance is too small. The number of steps (<code>maxnum</code>) is limited to 500 per invocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f_ctx</td><td>An arbitrary pointer that is passed as the first argument to all invocations of <code>f</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>A function that evaluates the right hand side of the ODE and stores the result in the array <code>yp</code>. Note that <code>y</code> and <code>yp</code> will not overlap.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neqn</td><td>The number of elements in the array <code>y</code>.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>On entry, the array is expected hold the initial value of the vector <code>y</code>. On return, it is replaced with integrated result.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">t</td><td>On entry, the argument is expected to hold the initial value of the variable <code>t</code>. On return, it is replaced with the value at which the integration stopped. When resuming integration, <code>t</code> must contain the same value as before.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tout</td><td>The target value of <code>t</code>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">relerr,abserr</td><td>The relative and absolute tolerances. At each step, the code maintains <code>fabs(local_error) &lt;= fabs(y) * relerr + abserr</code> for each component of the local error and solution vectors. Both are required to be positive.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>Bit flag containing some possibly empty combination of <code><a class="el" href="ode_8h.html#a6d090f9c9d67b32ab6de6dfd61129d25" title="Do not integrate beyond the target. ">SG_ODE_FSTRICT</a></code> and <code><a class="el" href="ode_8h.html#a8b3724c41ea6f775b552308803e67cd0" title="Use the value of iwork[5] to set the maximum number of iterations. ">SG_ODE_FMAXNUM</a></code>. If <code><a class="el" href="ode_8h.html#a6d090f9c9d67b32ab6de6dfd61129d25" title="Do not integrate beyond the target. ">SG_ODE_FSTRICT</a></code> is not specified, then the solver may integrate slightly past the target. If <code><a class="el" href="ode_8h.html#a8b3724c41ea6f775b552308803e67cd0" title="Use the value of iwork[5] to set the maximum number of iterations. ">SG_ODE_FMAXNUM</a></code> is set, the value of <code>iwork[5]</code> determines the maximum number of iterations, which would have otherwise been 500 by default.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">work</td><td>A buffer of length <code>21 * neqn + 100</code>. When resuming integration, it must retain the same contents as before. (The buffer does not need to be initialized when starting a new integration.)</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iwork</td><td>A buffer of length 5, or 6 if <code>SG_ODE_FMAXNUM</code> is set. When starting a new integration, all elements except <code>iwork[5]</code> <em>must be initialized to zero</em>. When resuming integration, it must retain the same contents as before.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the integration was successful. Otherwise, returns one of the following:<ul>
<li><code><a class="el" href="ode_8h.html#acd8b7658ea6af4651ddd33f0446b1d45" title="Integration did not reach target because the error tolerances were too small given the limitations of...">SG_ODE_ETOLER</a></code></li>
<li><code><a class="el" href="ode_8h.html#aaa4839531a8ce62974ea90edf01ff655" title="Integration did not reach target because more than maxnum steps were taken. ">SG_ODE_ESTEPS</a></code></li>
<li><code><a class="el" href="ode_8h.html#a05366a844e2aba52b77f70c26be15bab" title="Integration did not reach target because more than maxnum steps were taken. ">SG_ODE_ESTIFF</a></code></li>
<li><code><a class="el" href="ode_8h.html#afd33ed2bf091a695a266897f25e4d099" title="Invalid argument(s). ">SG_ODE_EINVAL</a></code> </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aef172a1555c391f633111a3b37d1daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef172a1555c391f633111a3b37d1daa9">&#9670;&nbsp;</a></span>sg_ode_de()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sg_ode_de </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSgOde.html">SgOde</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SgDerivFn *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>f_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&#160;</td>
          <td class="paramname"><em>relerr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&#160;</td>
          <td class="paramname"><em>abserr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *restrict&#160;</td>
          <td class="paramname"><em>iflag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates a system of <code>neqn</code> first order ordinary differential equations. </p>
<p>The equations are of the form: </p><pre class="fragment">dy[i]/dt = f(t, y[0], y[1], ..., y[neqn - 1])    y[i] given at t
</pre><p>The function integrates from <code>t</code> to <code>tout</code>. On return the parameters in the call list are set for continuing the integration. The user has only to define a new value <code>tout</code> and call <code>ode</code> again.</p>
<p>The differential equations are actually solved by a suite of codes <code>de</code>, <code>step</code>, and <code>interpolate</code>. <code>ode</code> allocates virtual storage in the <code>work</code> array and calls <code>de</code>. <code>de</code> is a supervisor which directs the solution. It calls on the routines <code>step</code> and <code>interpolate</code> to advance the integration and to interpolate at output points. <code>step</code> uses a modified divided difference form of the Adams PECE formulas and local extrapolation. It adjusts the order and step size to control the local error per unit step in a generalized sense. Normally each call to <code>step</code> advances the solution one step in the direction of <code>tout</code>. For reasons of efficiency <code>de</code> integrates beyond <code>tout</code> internally, though never beyond <code>t + 10 * (tout - t)</code>, and calls <code>interpolate</code> to interpolate the solution at <code>tout</code>. An option is provided to stop the integration at <code>tout</code> but it should be used only if it is impossible to continue the integration beyond <code>tout</code>.</p>
<p>This code is completely explained and documented in the text, Computer Solution of Ordinary Differential Equations: The Initial Value Problem L. F. Shampine and M. K. Gordon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function <code>f(f_ctx, t, y, yp)</code> to evaluate derivatives <code>yp[i] = dy[i]/dt</code></td></tr>
    <tr><td class="paramname">f_ctx</td><td>Arbitrary pointer passed to <code>f</code>.</td></tr>
    <tr><td class="paramname">y</td><td>Solution vector at <code>t</code> (length: <code>neqn</code>)</td></tr>
    <tr><td class="paramname">t</td><td>Independent variable (length: <code>1</code>)</td></tr>
    <tr><td class="paramname">tout</td><td>Point at which solution is desired</td></tr>
    <tr><td class="paramname">relerr</td><td>Relative error tolerance for local error test (length: <code>1</code>). At each step the code requires <code>fabs(local_error) &lt;= fabs(y) * relerr + abserr</code> for each component of the local error and solution vectors</td></tr>
    <tr><td class="paramname">abserr</td><td>Absolute error tolerance for local error test (length: <code>1</code>). See <code>relerr</code>.</td></tr>
    <tr><td class="paramname">iflag</td><td>Indicates status of integration</td></tr>
    <tr><td class="paramname">self</td><td>Arrays to hold information internal to <code>de</code> which is necessary for subsequent calls (length: <code>5</code>)</td></tr>
    <tr><td class="paramname">maxnum</td><td>Maximum number of steps allowed in one call to <code>de</code>.</td></tr>
  </table>
  </dd>
</dl>
<h1>First call to <code>ode</code></h1>
<p>The user must supply a function <code>f(f_ctx, t, y, yp)</code> to evaluate </p><pre class="fragment">dy[i]/dt = yp[i] = f(t, y[0], y[1], ..., y[neqn - 1])
</pre><p>and initialize the parameters:</p>
<ul>
<li><code>y</code>: Vector of initial conditions</li>
<li><code>t</code>: Starting point of integration</li>
<li><code>tout</code>: Point at which solution is desired</li>
<li><code>relerr, abserr</code>: Relative and absolute local error tolerances</li>
<li><code>iflag</code>: <code>+1</code> or <code>-1</code>. Indicator to initialize the code. Normal input is <code>+1</code>. The user should set <code>iflag = -1</code> only if it is impossible to continue the integration beyond <code>tout</code>.</li>
</ul>
<p>All parameters except <code>f</code> and <code>tout</code> may be altered by the code on output so must be variables in the calling program.</p>
<h1>Output from <code>ode</code></h1>
<ul>
<li><code>y</code>: Solution at <code>t</code></li>
<li><code>t</code>: Last point reached in integration. normal return has <code>t == tout</code>.</li>
<li><code>tout</code>: Unchanged</li>
<li><code>relerr</code>, <code>abserr</code>: normal return has tolerances unchanged. <code>iflag = 3</code> signals tolerances increased</li>
<li><code>iflag</code>: (Note: The value of <code>iflag</code> is returned negative when the input value is negative and the integration does not reach <code>tout</code>, i.e., <code>-3</code>, <code>-4</code>, <code>-5</code>.)<ul>
<li><code>2</code>: Normal return. Integration reached <code>tout</code>.</li>
<li><code>3</code>: Integration did not reach <code>tout</code> because error tolerances too small. <code>relerr</code>, <code>abserr</code> increased appropriately for continuing.</li>
<li><code>4</code>: Integration did not reach <code>tout</code> because more than <code>maxnum</code> steps needed.</li>
<li><code>5</code>: Integration did not reach <code>tout</code> because equations appear to be stiff.</li>
<li><code>6</code>: Invalid input parameters (fatal error).</li>
</ul>
</li>
<li><code>work</code>, <code>self</code>: Information generally of no interest to the user but necessary for subsequent calls.</li>
</ul>
<h1>Subsequent calls to <code>ode</code></h1>
<p>Function <code>ode</code> returns with all information needed to continue the integration. If the integration reached <code>tout</code>, the user need only define a new <code>tout</code> and call again. If the integration did not reach <code>tout</code> and the user wants to continue, simply call again. The output value of <code>iflag</code> is the appropriate input value for subsequent calls. The only situation in which it should be altered is to stop the integration internally at the new <code>tout</code>, i.e., change output <code>iflag = 2</code> to input <code>iflag = -2</code>. Error tolerances may be changed by the user before continuing. All other parameters must remain unchanged. </p>

</div>
</div>
<a id="a1ace58bd22a16a46d719739bf449a644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ace58bd22a16a46d719739bf449a644">&#9670;&nbsp;</a></span>sg_ode_interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sg_ode_interpolate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSgVectorDriver.html">SgVectorDriver</a>&#160;</td>
          <td class="paramname"><em>drv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict&#160;</td>
          <td class="paramname"><em>yout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *restrict&#160;</td>
          <td class="paramname"><em>ypout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>kold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vector_8h.html#ad9f4acf3aaf273070005a5b7f7444ee7">SgVector</a> *const restrict *&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *restrict&#160;</td>
          <td class="paramname"><em>psi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The methods in function <code>step</code> approximate the solution near <code>x</code> by a polynomial. </p>
<p>Function <code>interpolate</code> approximates the solution at <code>xout</code> by evaluating the polynomial there. Information defining this polynomial is passed from <code>step</code> so <code>interpolate</code> cannot be used alone.</p>
<h1>Input to <code>interpolate</code></h1>
<p>The user provides storage in the calling program for the arrays in the call list and defines <code>xout</code>, point at which solution is desired.</p>
<p>The remaining parameters are defined in <code>step</code> and passed to <code>interpolate</code> from that function.</p>
<h1>Output from <code>interpolate</code></h1>
<ul>
<li><code>yout</code>: Solution at <code>xout</code></li>
<li><code>ypout</code>: Derivative of solution at <code>xout</code></li>
</ul>
<p>The remaining parameters are returned unaltered from their input values. Integration with <code>step</code> may be continued. </p>

</div>
</div>
<a id="afb7225fd894aa50d3fcf62d5c5b1d5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7225fd894aa50d3fcf62d5c5b1d5df">&#9670;&nbsp;</a></span>sg_ode_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sg_ode_step </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structSgOde.html">SgOde</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SgDerivFn *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *restrict&#160;</td>
          <td class="paramname"><em>f_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *restrict&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrates a system of first order ordinary differential equations one step, normally from <code>x</code> to <code>x+h</code>, using a modified divided difference form of the Adams PECE formulas. </p>
<p>Local extrapolation is used to improve absolute stability and accuracy. The code adjusts its order and step size to control the local error per unit step in a generalized sense. Special devices are included to control roundoff error and to detect when the user is requesting too much accuracy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">self</td><td>The solver state. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The derivative function. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f_ctx</td><td>Arbitrary pointer for <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">eps</td><td>Local error tolerance. (length: <code>1</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Nonzero when no step can be taken, zero otherwise (<code>crash</code>).</dd></dl>
<p>The arrays <code>phi</code>, <code>psi</code> are required for the interpolation function <code>interpolate</code>. The array <code>p</code> is internal to the code.</p>
<h1>Input to <code>step</code></h1>
<h2>First call</h2>
<p>The user must provide storage in their driver program for all arrays in the call list, namely </p><pre class="fragment">y[neqn], wt[neqn], phi[neqn * 16], p[neqn], yp[neqn], psi[12]
</pre><p>The user must also declare the <code>start</code> Boolean variable and the function <code>f(f_ctx, x, y, yp)</code> to evaluate </p><pre class="fragment">dy[i]/dx = yp[i] = f(x, y[0], y[1], ..., y[neqn - 1])
</pre><p>and initialize only the following parameters:</p>
<ul>
<li><code>x</code>: Initial value of the independent variable</li>
<li><code>y</code>: Vector of initial values of dependent variables</li>
<li><code>h</code>: Nominal step size indicating direction of integration and maximum size of step.</li>
<li><code>eps</code>: Local error tolerance per step.</li>
<li><code>wt</code>: Vector of non-zero weights for error criterion</li>
<li><code>start</code>: Set to <code>true</code>.</li>
</ul>
<p><code>step</code> requires the L2 norm of the vector with components <code>local_error[l] / wt[l]</code> be less than <code>eps</code> for a successful step. The array <code>wt</code> allows the user to specify an error test appropriate for their problem. For example,</p>
<ul>
<li><code>wt[l] = 1.0</code> specifies absolute error,</li>
<li><code>wt[l] = fabs(y[l])</code> error relative to the most recent value of the l-th component of the solution,</li>
<li><code>wt[l] = fabs(yp[l])</code> error relative to the most recent value of the l-th component of the derivative,</li>
<li><code>wt[l] = max(wt[l], fabs(y[l]))</code> error relative to the largest magnitude of l-th component obtained so far,</li>
<li><code>wt[l] = fabs(y(l)) * relerr / eps + abserr / eps</code> specifies a mixed relative-absolute test where <code>relerr</code> is relative error, <code>abserr</code> is absolute error and <code>eps = max(relerr, abserr)</code>.</li>
</ul>
<h2>Subsequent calls</h2>
<p>Function <code>step</code> is designed so that all information needed to continue the integration, including the step size <code>h</code> and the order <code>k</code>, is returned with each step. With the exception of the step size, the error tolerance, and the weights, none of the parameters should be altered. The array <code>wt</code> must be updated after each step to maintain relative error tests like those above. Normally the integration is continued just beyond the desired endpoint and the solution interpolated there with <code>interpolate</code>. If it is impossible to integrate beyond the endpoint, the step size may be reduced to hit the endpoint since the code will not take a step larger than the <code>h</code> input. Changing the direction of integration, i.e., the sign of h , requires the user set <code>start = true</code> before calling <code>step</code> again. This is the only situation in which <code>start</code> should be altered.</p>
<h1>Output from <code>step</code></h1>
<h2>Successful step</h2>
<p>The function returns zero after each successful step with <code>start</code> set to <code>false</code>. <code>x</code> represents the independent variable advanced one step of length hold from its value on input and <code>y</code> the solution vector at the new value of <code>x</code>. All other parameters represent information corresponding to the new <code>x</code> needed to continue the integration.</p>
<h2>Unsuccessful step</h2>
<p>When the error tolerance is too small for the machine precision, the function returns nonzero without taking a step. An appropriate step size and error tolerance for continuing are estimated and all other information is restored as upon input before returning. To continue with the larger tolerance, the user just calls the code again. A restart is neither required nor desirable. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
